# 2023-10-06

Tags: Python, Flask, SQLite, SQLAlchemy

## Top 10 Movie Website

I'm taking this opportunity to learn more about file structure, going beyond the requirements of the lesson in an effort to figure out how real projects are structured.

```
ğŸ“ app
â”‚   â”œâ”€â”€ ğŸ __init__.py
â”‚   â””â”€â”€ ğŸ›£ï¸ routes.py
ğŸ“ instance
â”‚   â””â”€â”€ ğŸ—„ï¸ movies.db
ğŸ“ models
â”‚   â”œâ”€â”€ ğŸ“‹ forms.py
â”‚   â””â”€â”€ ğŸ¬ movie.py
ğŸ“ services
â”‚   â””â”€â”€ âš™ï¸ services.py
ğŸ“ static
â”‚   â””â”€â”€ ğŸ“ css
â”‚       â””â”€â”€ ğŸ¨ styles.css
ğŸ“ templates
â”‚   â”œâ”€â”€ â• add.html
â”‚   â”œâ”€â”€ ğŸ“œ base.html
â”‚   â”œâ”€â”€ âœï¸ edit.html
â”‚   â”œâ”€â”€ ğŸ  index.html
â”‚   â””â”€â”€ ğŸ” select.html
ğŸ“„ ğŸƒ run.py
```

This is the structure I chose for this project. There is no one right way to structure Flask apps, but from what I understand this flat structure is more conducive to expansion in the future if you want to make dev, test, and prod versions of the app.

### app
```
ğŸ“ app
â”‚   â”œâ”€â”€ ğŸ __init__.py
â”‚   â””â”€â”€ ğŸ›£ï¸ routes.py
```
In the app folder we have an `__init__.py` file and a `routes.py` file. The init file does a few things.

```python
# __init__.py
from flask import Flask
from flask_bootstrap import Bootstrap5
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()
bootstrap = Bootstrap5()


def create_app():
    app = Flask(__name__, template_folder="../templates", static_folder="../static")
    app.config["SECRET_KEY"] = "8BYkEfBA6O6donzWlSihBXox7C0sKR6b"
    app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///movies.db"

    bootstrap.init_app(app)
    db.init_app(app)

    from app.routes import main

    app.register_blueprint(main)

    with app.app_context():
        db.create_all()

    return app
```

The pattern we're using here is called an application factory.

First we instantiate the database and Bootstrap outside of the `create_app()` function. There are two reasons for this. One is that you can then easily access these variables outside of this file, and the second is that we can write multiple `create_app()` functions to create dev, test, and prod environments with different configurations.

Then, within the `create_app()` function, we're creating the `app` variable, pointing at the correct location of the template folder (since this init file and the templates folder are no longer on a flat file structure at the root). Then we set the secret key necessary for generating `wtforms` tokens as well as the SQLAlchemy database URI.

After setting these configurations, we then initialize Bootstrap and the database by passing the Flask app to them so they can understand the context they're working with.

Next we import the `main` variable from the `app.routes` package which is a Flask `Blueprint` object. These allow you to avoid circular imports where the 